#include "dprec.fh"
!&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
!This file contains subroutines to include COSMO and Onsager type continuum
!models in ground and excited state calculations. Routines specific to COSMO
!cavity construction, cholesky factorization, and COSMO gradients are found in
!cosmo.f90
!
! Josiah A. Bjorgaard, Vasyl Kuzmenko, Kirill Velizhanin
! 2013-2014 Los Alamos National Laboratory
!
!&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
!THIS SUBROUTINE REPLACES Lxi IN THE DAVIDSON ROUTINE WHEN A SOLVENT MODEL IS
!USED, IT INCLUDES ALL SOLVENT MODELS DESIGNATED BY solvent_model and
!potential_type
!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
subroutine Lxi_testing(qm2_params, qmmm_nml, qmmm_mpi, cosmo_c_struct, qm2_struct, qm2ds, qmmm_struct, u1, v1, solvent_model)
    use qm2_davidson_module
    use qmmm_module, only : qm2_structure, qmmm_mpi_structure;
    use cosmo_C, only : cosmo_C_structure
    use qmmm_struct_module, only : qmmm_struct_type
    use qm2_params_module, only : qm2_params_type
    use qmmm_nml_module, only : qmmm_nml_type

    implicit none
    type(qmmm_nml_type), intent(inout) :: qmmm_nml
    type(qm2_params_type), intent(inout) :: qm2_params
    type(qmmm_mpi_structure), intent(inout) :: qmmm_mpi

    type(cosmo_C_structure), intent(inout) :: cosmo_c_struct
    type(qm2_structure), intent(inout) :: qm2_struct
    type(qm2_davidson_structure_type), intent(inout) :: qm2ds
    type(qmmm_struct_type), intent(inout) :: qmmm_struct
    _REAL_ u1(qm2ds%Nrpa), v1(qm2ds%Nrpa)
    _REAL_ f, f1, f2, fs1, ddot
    integer i, j, p, h
    integer one
    integer solvent_model
    _REAL_ tmp(qm2ds%nb, qm2ds%nb), tmp2(qm2ds%nb, qm2ds%nb);
    parameter(one=1)

    fs1 = 0;
    qm2ds%xi = 0.d0
    call mo2site(qm2ds, u1, qm2ds%xi, qm2ds%eta) !Change basis of guess vector of Davidson from M.O to A.O
    qm2ds%eta = 0.0;
    call Vxi(qm2_params, qmmm_mpi, qm2_struct, qm2ds, qmmm_struct, qm2ds%xi, qm2ds%eta); !Calculate Vacuum Electron Correlation
    !!SELECT SOLVENT MODEL AND POTENTIAL TYPE
    if ((solvent_model .eq. 1)) then !1:Linear Response
        tmp = 0.d0;
        if (cosmo_c_struct%potential_type .eq. 3) then !COSMO Potential
            call VxiM(cosmo_c_struct, qm2ds, qm2ds%xi, tmp);
        elseif (cosmo_c_struct%potential_type .eq. 2) then !Onsager Potential
            call rcnfld(qm2_params, qmmm_nml, cosmo_c_struct, qm2_struct, qmmm_struct, tmp, qm2ds%xi, qm2ds%nb)
        elseif (cosmo_c_struct%potential_type .eq. 1) then !testing
            do i = 1, qm2ds%nb; tmp(i, i) = qm2ds%eta(qm2ds%nb*(i - 1) + i); end do !double diag vac correlation
        end if
        tmp = tmp
        call VxiM_end(qm2_struct, qm2ds%eta, tmp); !Add selected potential to vacuum correlation
    elseif (solvent_model .eq. 99) then !For Z-vector equation if different
        tmp = 0.d0;
        if (cosmo_c_struct%potential_type .eq. 3) then !COSMO Potential
            call VxiM(cosmo_c_struct, qm2ds, qm2ds%xi, tmp);
        elseif (cosmo_c_struct%potential_type .eq. 2) then !Onsager Potential
            call rcnfld(qm2_params, qmmm_nml, cosmo_c_struct, qm2_struct, qmmm_struct, tmp, qm2ds%xi, qm2ds%nb)
        elseif (cosmo_c_struct%potential_type .eq. 1) then !testing
            do i = 1, qm2ds%nb; tmp(i, i) = qm2ds%eta(qm2ds%nb*(i - 1) + i); end do !double diag vac correlation
        end if
        tmp = 2*tmp
        call VxiM_end(qm2_struct, qm2ds%eta, tmp); !Add selected potential to vacuum correlation
    elseif (solvent_model .eq. 98) then !For Z-vector equation with SS model
        tmp = 0.d0;
        if (cosmo_c_struct%potential_type .eq. 3) then !COSMO Potential
            call VxiM(cosmo_c_struct, qm2ds, qm2ds%xi, tmp);
        elseif (cosmo_c_struct%potential_type .eq. 2) then !Onsager Potential
            call rcnfld(qm2_params, qmmm_nml, cosmo_c_struct, qm2_struct, qmmm_struct, tmp, qm2ds%xi, qm2ds%nb)
        elseif (cosmo_c_struct%potential_type .eq. 1) then !testing
            do i = 1, qm2ds%nb; tmp(i, i) = qm2ds%eta(qm2ds%nb*(i - 1) + i); end do !double diag vac correlation
        end if
        call VxiM_end(qm2_struct, qm2ds%eta, tmp); !Add selected potential to vacuumcorrelation
        !Commutator is performed here for State Specific Solvent Routines
        tmp = 0.d0;
        call commutator(qm2ds%xi, cosmo_c_struct%v_solvent_difdens, qm2ds%Nb, tmp, .false.)
        call VxiM_end(qm2_struct, qm2ds%eta, tmp)
    elseif (solvent_model .eq. 2) then ! 2: State Specific [V_s(T+Z),xi]
        tmp = 0.d0;
        !Commutator is performed here for State Specific Solvent Routines
        call commutator(qm2ds%xi, cosmo_c_struct%v_solvent_difdens, qm2ds%Nb, tmp, .false.)
        call VxiM_end(qm2_struct, qm2ds%eta, tmp)
    elseif (solvent_model .eq. 3) then !3: State Specific [V_s(xi),xi]
        call commutator(cosmo_c_struct%v_solvent_xi, qm2ds%xi, qm2ds%Nb, tmp, .false.)
        call VxiM_end(qm2_struct, qm2ds%eta, tmp)
    elseif (solvent_model .eq. 5) then !5: Variational State Specific term
        call commutator(qm2ds%xi, cosmo_c_struct%v_solvent_difdens, qm2ds%Nb, tmp, .false.)
        call VxiM_end(qm2_struct, qm2ds%eta, tmp)
        write (6, *) 'Adding variational term in Liouville operator'
    elseif (solvent_model .eq. 6) then!6: Solve nonlinear Liouville equation testing
        call commutator(qm2ds%eta, qm2ds%xi, qm2ds%Nb, tmp, .false.)
        call VxiM_end(qm2_struct, qm2ds%eta, tmp)
    elseif (solvent_model .eq. 10) then!10: NO GS Solvent test
        tmp = 0.d0; tmp2 = 0.d0;
        call rcnfld_fock(qm2_params, qmmm_nml, cosmo_c_struct, qm2_struct, qmmm_struct, &
            tmp, qm2_struct%den_matrix, qm2ds%Nb)
        call unpacking(qm2ds%Nb, tmp, tmp2, 's'); tmp = 0.d0;
        call commutator(tmp2, qm2ds%xi, qm2ds%Nb, tmp, .false.)
        call VxiM_end(qm2_struct, qm2ds%eta, tmp)
    elseif (solvent_model .eq. 7) then!7: combined LR and VE
    end if

    !add constant electric field potential [V_E,xi]
    if (cosmo_c_struct%EF .eq. 2) then!Constant Electric Field in ES only
        tmp = 0.d0; tmp2 = 0.d0
        call efield_fock(qm2_params, qmmm_nml, cosmo_c_struct, qm2_struct, qm2ds, qmmm_struct, tmp, qm2ds%Nb)
        call unpacking(qm2ds%Nb, tmp, tmp2, 's'); tmp = 0.d0
        call commutator(qm2ds%xi, tmp2, qm2ds%Nb, tmp, .false.)
        call VxiM_end(qm2_struct, qm2ds%eta, tmp)
    end if

    call site2mo(qm2ds, qm2ds%xi, qm2ds%eta, v1); !Change basis of xi again to M.O.

    i = 0
    do p = 1, qm2ds%Np
        do h = qm2ds%Np + 1, qm2ds%Nb
            i = i + 1
            f = qm2ds%ehf(h) - qm2ds%ehf(p);
            !JAB Test
            v1(i) = v1(i) + f*u1(i)
            v1(i + qm2ds%Ncis) = -(v1(i + qm2ds%Ncis) + f*u1(i + qm2ds%Ncis))
        end do
    end do
    do i = 1, qm2ds%Nrpa
        qm2ds%temp1(i) = qm2ds%v0(i, 1)
        qm2ds%temp2(i) = u1(i)
    end do

    if (qm2ds%Mj .gt. 0) then
        write (6, *) 'In the weird block' !!JAB
        fs1 = qm2ds%fs + qm2ds%e0(qm2ds%Mj)
        do j = 1, qm2ds%Mj
            f1 = fs1*(ddot(qm2ds%Ncis, qm2ds%v0(1, j), one, u1(1), one) &
                - ddot(qm2ds%Ncis, qm2ds%v0(qm2ds%Ncis + 1, j), one, u1(qm2ds%Ncis + 1), one))
            f2 = fs1*(ddot(qm2ds%Ncis, qm2ds%v0(qm2ds%Ncis + 1, j), one, u1(1), one) &
                - ddot(qm2ds%Ncis, qm2ds%v0(1, j), one, u1(qm2ds%Ncis + 1), one))

            call daxpy(qm2ds%Ncis, f1, qm2ds%v0(1, j), one, v1(1), one)
            call daxpy(qm2ds%Ncis, f2, qm2ds%v0(1 + qm2ds%Ncis, j), one, v1(1), one)
            call daxpy(qm2ds%Ncis, f1, qm2ds%v0(1 + qm2ds%Ncis, j), &
                one, v1(1 + qm2ds%Ncis), one)
            call daxpy(qm2ds%Ncis, f2, qm2ds%v0(1, j), one, v1(1 + qm2ds%Ncis), one)

        end do
    end if
end subroutine Lxi_testing

!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
!THIS SUBROUTINE CALCULATES THE SOLVENT POTENTIAL OPERATOR V_S FOR COSMO USING CHOLESKY FACTORIZATION
!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
subroutine VxiM(cosmo_c_struct, qm2ds, xi, Vximmat)
    use qm2_davidson_module
    use cosmo_C, only : cosmo_C_structure, a0, ev
    implicit none
    type(qm2_davidson_structure_type), intent(inout) :: qm2ds
    type(cosmo_C_structure), intent(inout) :: cosmo_c_struct

    _REAL_, intent(in)::xi(qm2ds%nb, qm2ds%nb)
    _REAL_, intent(inout)::Vximmat(qm2ds%nb, qm2ds%nb)
    _REAL_ :: density(cosmo_c_struct%lm61), charges(cosmo_c_struct%nps), phi(cosmo_c_struct%nps)
    _REAL_ :: p(qm2ds%nb*(qm2ds%nb + 1)/2), fcon
    integer:: i, im

    fcon = cosmo_c_struct%fepsi*a0*ev !scaling factor
    call packing(qm2ds%nb, xi, p, 's') !Note that the factor of two for diagonal elements which happens in this subroutine is corrected for by cosmo_c_struct%gden
    ! FIRST CALCULATE QDENEL FROM DENSITY MATRIX
    do i = 1, cosmo_c_struct%lm61
        density(i) = cosmo_c_struct%gden(i)*p(cosmo_c_struct%ipiden(i))
    end do
    !  NOW CALCULATE PHIEL FROM BMAT*QDENEL
    call DGEMV('T', cosmo_c_struct%lm61, cosmo_c_struct%nps, 1.d0, cosmo_c_struct%bmat, &
        cosmo_c_struct%lm61, density, 1, 0.d0, phi, 1) !LAPACK subroutine for above
    ! NOW CALCULATE CHARGES
    call coscl2(cosmo_c_struct%amat, cosmo_c_struct%nsetf, charges, phi, cosmo_c_struct%nps) !Use cholesky factorization routine

    ! NOW ADD BMAT*QSCEL TO FOCK MATRIX
    call DGEMV('N', cosmo_c_struct%lm61, cosmo_c_struct%nps, fcon, cosmo_c_struct%bmat, &
        cosmo_c_struct%lm61, charges, 1, 0.d0, density, 1) !LAPACK subroutine for above
    p = 0.d0
    do i = 1, cosmo_c_struct%lm61;
        im = cosmo_c_struct%ipiden(i); p(im) = density(i); !in A.U.
    end do
    call unpacking(qm2ds%nb, p, Vximmat, 's')
end subroutine VxiM

!^^^^^^^^^^^^^^^^^^^^^^^
 !!ADD tmp to Vximmat...
!^^^^^^^^^^^^^^^^^^^^^^^
subroutine VxiM_end(qm2_struct, Vximmat, tmp)
    use qmmm_module, only : qm2_structure;
    implicit none
    type(qm2_structure), intent(inout) :: qm2_struct
    _REAL_, intent(inout)::tmp(qm2_struct%norbs, qm2_struct%norbs);
    _REAL_, intent(inout)::Vximmat(qm2_struct%norbs, qm2_struct%norbs);
    !Modifing Vxi=Vxi+Mxi;
    Vximmat(1:qm2_struct%norbs, 1:qm2_struct%norbs) = &
        Vximmat(1:qm2_struct%norbs, 1:qm2_struct%norbs) + &
        tmp(1:qm2_struct%norbs, 1:qm2_struct%norbs);
end subroutine VxiM_end

!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 !!ADD tmp to Vximmat if tmp is the vector of a diagonal matrix
!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
subroutine VxiM_end45(qm2_struct, Vximmat, tmp)
    use qmmm_module, only : qm2_structure;
    implicit none
    type(qm2_structure), intent(inout) :: qm2_struct
    _REAL_, intent(inout)::tmp(qm2_struct%norbs);
    _REAL_, intent(inout)::Vximmat(qm2_struct%norbs, qm2_struct%norbs);
    integer i;
    do i = 1, qm2_struct%norbs
        Vximmat(i, i) = Vximmat(i, i) + 2*tmp(i);
    end do
end subroutine VxiM_end45

!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
!SUBROUTINE FOR DIRECT CALCULATION OF A COMMUTATOR
!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
subroutine commutator(A, B, matrix_size, res, flag);
    integer matrix_size;
    logical flag;
    _REAL_, dimension(matrix_size, matrix_size) :: A, B, Res;
    _REAL_, dimension(:, :), allocatable :: tmp
    _REAL_ ALPHA;
    _REAL_ BETA;
    ALPHA = 1.0D+0;
    BETA = 0.0D+0;
    allocate (tmp(matrix_size, matrix_size));
    if (flag) then !Transpose A if flag
        call DGEMM('T', 'N', matrix_size, matrix_size, matrix_size, ALPHA, A, &
            matrix_size, B, matrix_size, BETA, res, matrix_size);
        call DGEMM('N', 'T', matrix_size, matrix_size, matrix_size, ALPHA, B, &
            matrix_size, A, matrix_size, BETA, tmp, matrix_size);
    else !Otherwise no transpose
        call DGEMM('N', 'N', matrix_size, matrix_size, matrix_size, ALPHA, A, &
            matrix_size, B, matrix_size, BETA, res, matrix_size);
        call DGEMM('N', 'N', matrix_size, matrix_size, matrix_size, ALPHA, B, &
            matrix_size, A, matrix_size, BETA, tmp, matrix_size);
    end if;
    res = res - tmp;
    deallocate (tmp);
    return
end subroutine commutator

!&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
! Onsager-type solvent model (single point and gradient)functions
! and Electric field potentials are below
!
! Josiah A. Bjorgaard, Vasyl Kuzmenko, Kirill Velizhanin
! 2013-2014 Los Alamos National Laboratory
!
!&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
!ONSAGER-TYPE DIPOLE CAVITY SCREENING WITHOUT NUCLEAR TERMS FOR
!EXCITED STATE CALCULATIONS
!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
subroutine rcnfld(qm2_params, qmmm_nml, cosmo_c_struct, qm2_struct, qmmm_struct, f, p, n)
    use cosmo_C, only : cosmo_C_structure
    use constants, only : one, BOHRS_TO_A, AU_TO_EV
    use qmmm_struct_module, only : qmmm_struct_type
    use qmmm_module, only : qm2_structure
    use qm2_params_module, only : qm2_params_type
    use qmmm_nml_module, only : qmmm_nml_type

    implicit none;
    type(qm2_params_type), intent(inout) :: qm2_params
    type(qmmm_nml_type), intent(inout) :: qmmm_nml
    type(qm2_structure), intent(inout) :: qm2_struct
    type(qmmm_struct_type), intent(inout) :: qmmm_struct
    type(cosmo_C_structure), intent(inout) :: cosmo_c_struct
    integer n, i, j;
    _REAL_ f(n, n);
    _REAL_ p(n, n);
    _REAL_ tmp(n, n);
    _REAL_ dipx(n, n), dipy(n, n), dipz(n, n);
    _REAL_ dip(3, n*(n + 1)/2);
    _REAL_ scaled(3), elec_dip(3);
    tmp = 0.d0
    dip = 0.d0
    dipx = 0.d0
    dipy = 0.d0
    dipz = 0.d0
    !!GET ELEC DIP MATRIX
    call get_dipole_matrix(qm2_params, qmmm_nml, qm2_struct, qmmm_struct, qmmm_struct%qm_coords, dip)
    call unpacking(n, dip(1, :), dipx, 's')
    call unpacking(n, dip(2, :), dipy, 's')
    call unpacking(n, dip(3, :), dipz, 's')

    !!CALC TOTAL AND ELECTRIC DIP
    elec_dip(1:3) = 0.0
    do i = 1, n
        do j = 1, n
            elec_dip(1) = elec_dip(1) + P(i, j)*dipx(i, j)
            elec_dip(2) = elec_dip(2) + P(i, j)*dipy(i, j)
            elec_dip(3) = elec_dip(3) + P(i, j)*dipz(i, j)
        end do
    end do

    !!CALCULATE SCALING FACTOR AND INDUCED DIPOLE
    scaled = (cosmo_c_struct%fepsi/cosmo_c_struct%onsager_radius**3)*elec_dip*BOHRS_TO_A*AU_TO_EV; ! for units of eV

    !!CALCULATE REACTION FIELD POTENTIAL
    f = f - 2.d0*(scaled(1)*dipx + scaled(2)*dipy + scaled(3)*dipz); !in eV
    return
end subroutine rcnfld

!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
!ONSAGER-TYPE SOLVENT MODEL GRADIENT FOR TWO TRIANGULAR MATRICES i.e. tr(F(rho)Z)
!WITH OR WITHOUT NUCLEAR PART OF FOCK MATRIX
!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
subroutine rcnfldgrad2(qm2_params, qmmm_nml, cosmo_c_struct, qm2_struct, qmmm_struct, dxyz, p1, p2, n, calc_nuc)
    use qmmm_module, only : qm2_structure;
    use cosmo_C, only : cosmo_C_structure!cosmo_c_struct%fepsi,cosmo_c_struct%onsager_radius,cosmo_c_struct%numat;
    use constants, only : one, BOHRS_TO_A, AU_TO_EV, EV_TO_KCAL
    use qmmm_struct_module, only : qmmm_struct_type
    use qm2_params_module, only : qm2_params_type
    use qmmm_nml_module, only : qmmm_nml_type

    implicit none;
    type(qm2_params_type), intent(inout) :: qm2_params
    type(qmmm_nml_type), intent(inout) :: qmmm_nml
    type(cosmo_C_structure), intent(inout) :: cosmo_c_struct
    type(qm2_structure), intent(inout) :: qm2_struct
    type(qmmm_struct_type), intent(inout) :: qmmm_struct

    integer::  i, i1, i2, i3, j, k;
    integer::  n
    _REAL_ ::  dxyz(3, cosmo_c_struct%numat), origin(3, cosmo_c_struct%numat)
    _REAL_ ::  p1(n*(n + 1)/2), p2(n*(n + 1)/2)
    _REAL_ ::  dip(3, n*(n + 1)/2);
    _REAL_ ::  scaled1(3), scaled2(3), scaled_nuc(3) &
        , elec_dip1(3), elec_dip2(3), nuc_dip(3), q_elec1, q_elec2
    logical::  calc_nuc

    dxyz = 0.d0; elec_dip1 = 0.d0; elec_dip2 = 0.d0
    nuc_dip = 0.d0; dip = 0.d0; q_elec1 = 0.d0; q_elec2 = 0.d0

    call centercoords(cosmo_c_struct, qmmm_struct, origin)
    !!GET NUC DIP MAT and CALC NUC DIP
    call get_nuc_dip(qm2_params, qmmm_nml, qm2_struct, qmmm_struct, qmmm_struct%qm_coords - origin, dip);
    nuc_dip(1) = sum(dip(1, :))!NUCLEAR DIPOLE IN a.u. * angstrom
    nuc_dip(2) = sum(dip(2, :))
    nuc_dip(3) = sum(dip(3, :))
    dip = 0.d0

    !ELECTRIC DIPOLE
    call get_dipole_matrix(qm2_params, qmmm_nml, qm2_struct, qmmm_struct, qmmm_struct%qm_coords - origin, dip)
    i = 1
    do j = 1, n
        do k = 1, j
            if (j .eq. k) then
                elec_dip1 = elec_dip1 + P1(i)*dip(:, i) !diagonal
                elec_dip2 = elec_dip2 + P2(i)*dip(:, i)
            else
                elec_dip1 = elec_dip1 + P1(i)*dip(:, i)*2.d0 !off-diagonal
                elec_dip2 = elec_dip2 + P2(i)*dip(:, i)*2.d0
            end if
            i = i + 1
        end do
    end do

    !! CALCULATE SCALING FACTOR AND INDUCED DIPOLES
    scaled1 = (cosmo_c_struct%fepsi/cosmo_c_struct%onsager_radius**3)*elec_dip1*BOHRS_TO_A*AU_TO_EV*EV_TO_KCAL
    scaled2 = (cosmo_c_struct%fepsi/cosmo_c_struct%onsager_radius**3)*elec_dip2*BOHRS_TO_A*AU_TO_EV*EV_TO_KCAL
    scaled_nuc = (cosmo_c_struct%fepsi/cosmo_c_struct%onsager_radius**3)*nuc_dip*BOHRS_TO_A*AU_TO_EV*EV_TO_KCAL

    !!CALCULATE DERIVATIVES
    i3 = 1
    do k = 1, cosmo_c_struct%numat
        i1 = qm2_params%orb_loc(1, k)
        i2 = qm2_params%orb_loc(2, k)
        do i = i1, i2
            do j = 1, 3
                dxyz(j, k) = dxyz(j, k) + 2*(p1(i3)*scaled2(j) + scaled1(j)*p2(i3)) !E-E parts
                if (calc_nuc) dxyz(j, k) = dxyz(j, k) + 2*scaled_nuc(j)*p2(i3) !N-E part
            end do
            q_elec1 = q_elec1 + p1(i3)
            q_elec2 = q_elec2 + p2(i3)
            i3 = i3 + i + 1 !diagonal indices
        end do
        if (calc_nuc) dxyz(:, k) = dxyz(:, k) - 2*qm2_params%core_chg(k)*scaled2 !N-E part
    end do
    do j = 1, 3 !Translation
        dxyz(j, :) = dxyz(j, :) - 2*(q_elec1*scaled2(j) + scaled1(j)*q_elec2)/cosmo_c_struct%numat !E-E
        if (calc_nuc) dxyz(j, :) = dxyz(j, :) + 2*sum(qm2_params%core_chg)*scaled2(j)/cosmo_c_struct%numat &
            - 2*scaled_nuc(j)*q_elec2/cosmo_c_struct%numat !N-E
    end do
end subroutine rcnfldgrad2

!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
!ONSAGER-TYPE POTENTIAL GRADIENT FOR GS, i.e. tr(F(rho)rho) INCLUDING
!NUCLEAR-ELECTRON PART AND NUCLEAR-NUCLEAR GRADIENT
!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
subroutine rcnfldgrad(qm2_params, qmmm_nml, cosmo_c_struct, qm2_struct, qmmm_struct, dxyz, p, n)
    use qmmm_module, only : qm2_structure;
    use cosmo_C, only : cosmo_C_structure !fepsi,onsager_radius,numat;
    use constants, only : one, BOHRS_TO_A, AU_TO_EV, EV_TO_KCAL
    use qm2_params_module, only : qm2_params_type
    use qmmm_nml_module, only : qmmm_nml_type
    use qmmm_struct_module, only : qmmm_struct_type

    implicit none;
    type(qm2_params_type), intent(inout) :: qm2_params
    type(qmmm_nml_type), intent(inout) :: qmmm_nml
    type(cosmo_C_structure), intent(inout) :: cosmo_c_struct
    type(qmmm_struct_type), intent(inout) :: qmmm_struct
    type(qm2_structure), intent(inout) :: qm2_struct

    integer::  i, i1, i2, i3, j, k;
    integer::  n
    _REAL_ ::  dxyz(3, cosmo_c_struct%numat), origin(3, cosmo_c_struct%numat)
    _REAL_ ::  p(n*(n + 1)/2)
    _REAL_ ::  dip(3, n*(n + 1)/2);
    _REAL_ ::  scaled(3), elec_dip(3), nuc_dip(3), q_elec

    dxyz = 0.d0; elec_dip = 0.d0
    nuc_dip = 0.d0; dip = 0.d0; q_elec = 0.d0

    call centercoords(cosmo_c_struct, qmmm_struct, origin)
    !!GET NUC DIP MAT and CALC NUC DIP
    call get_nuc_dip(qm2_params, qmmm_nml, qm2_struct, qmmm_struct, qmmm_struct%qm_coords - origin, dip);
    nuc_dip(1) = sum(dip(1, :))!NUCLEAR DIPOLE IN a.u. * angstrom
    nuc_dip(2) = sum(dip(2, :))
    nuc_dip(3) = sum(dip(3, :))
    dip = 0.d0

    !ELECTRIC DIPOLE
    call get_dipole_matrix(qm2_params, qmmm_nml, qm2_struct, qmmm_struct, qmmm_struct%qm_coords - origin, dip)
    i = 1
    do j = 1, n
        do k = 1, j
            if (j .eq. k) elec_dip = elec_dip + P(i)*dip(:, i) !diagonal
            if (j .ne. k) elec_dip = elec_dip + P(i)*dip(:, i)*2.d0 !off-diagonal
            i = i + 1
        end do
    end do

    !! CALCULATE SCALING FACTOR
    scaled = (cosmo_c_struct%fepsi/cosmo_c_struct%onsager_radius**3)*(elec_dip + nuc_dip)*BOHRS_TO_A*AU_TO_EV*EV_TO_KCAL;
    !!CALCULATE DERIVATIVES
    i3 = 1
    do k = 1, cosmo_c_struct%numat
        i1 = qm2_params%orb_loc(1, k)
        i2 = qm2_params%orb_loc(2, k)
        do i = i1, i2
            do j = 1, 3
                dxyz(j, k) = dxyz(j, k) + 2*p(i3)*scaled(j) !E-E,E-N parts
            end do
            q_elec = q_elec + p(i3)
            i3 = i3 + i + 1 !diagonal indices
        end do
        dxyz(:, k) = dxyz(:, k) - 2*qm2_params%core_chg(k)*scaled !N-N,N-E parts
    end do
end subroutine rcnfldgrad

!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
!GRADIENT FOR ONSAGER POTENTIAL FOR FULLL MATRICES, i.e. tr(V(xi)xi^(+))
!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
subroutine rcnfldgrad_full(qm2_params, qmmm_nml, cosmo_c_struct, qm2_struct, qmmm_struct, dxyz, p, n)
    use cosmo_C, only : cosmo_C_structure !fepsi,onsager_radius,cosmo_c_struct%numat;
    use constants, only : one, BOHRS_TO_A, AU_TO_EV, EV_TO_KCAL
    use qmmm_module, only : qm2_structure
    use qm2_params_module, only : qm2_params_type
    use qmmm_nml_module, only : qmmm_nml_type
    use qmmm_struct_module, only : qmmm_struct_type

    implicit none;
    type(cosmo_C_structure), intent(inout) :: cosmo_c_struct
    type(qmmm_struct_type), intent(inout) :: qmmm_struct
    type(qm2_structure), intent(inout) :: qm2_struct
    type(qm2_params_type), intent(inout) :: qm2_params
    type(qmmm_nml_type), intent(inout) :: qmmm_nml

    integer::  i, i1, i2, j, k;
    integer::  n
    _REAL_ ::  dxyz(3, cosmo_c_struct%numat), origin(3, cosmo_c_struct%numat)
    _REAL_ ::  p(n**2)
    _REAL_ ::  dip(3, n*(n + 1)/2), dip2(3, n**2);
    _REAL_ ::  scaled(3), elec_dip(3), nuc_dip(3), q_elec

    dxyz = 0.d0; elec_dip = 0.d0
    nuc_dip = 0.d0; dip = 0.d0; dip2 = 0.d0; q_elec = 0.d0
    call centercoords(cosmo_c_struct, qmmm_struct, origin)

    !!GET ELEC DIP MATRIX
    call get_dipole_matrix(qm2_params, qmmm_nml, qm2_struct, qmmm_struct, qmmm_struct%qm_coords - origin, dip)
    call unpacking(n, dip(1, :), dip2(1, :), 's')
    call unpacking(n, dip(2, :), dip2(2, :), 's')
    call unpacking(n, dip(3, :), dip2(3, :), 's')

    call get_dipole_matrix(qm2_params, qmmm_nml, qm2_struct, qmmm_struct, qmmm_struct%qm_coords - origin, dip)

    do i = 1, 3
        elec_dip(i) = sum(P*dip2(i, :)) !diagonal
    end do

    !! CALCULATE SCALING FACTOR
    scaled = (cosmo_c_struct%fepsi/cosmo_c_struct%onsager_radius**3)*elec_dip*BOHRS_TO_A*AU_TO_EV*EV_TO_KCAL;
    !!CALCULATE DERIVATIVES
    do k = 1, cosmo_c_struct%numat
        i1 = qm2_params%orb_loc(1, k)
        i2 = qm2_params%orb_loc(2, k)
        do i = i1, i2;
            do j = 1, 3
                dxyz(j, k) = dxyz(j, k) + 4*2*P((i - 1)*n + i)*scaled(j)
            end do
            q_elec = q_elec + P((i - 1)*n + i)
        end do
    end do
    do j = 1, 3 !Translation
        dxyz(j, :) = dxyz(j, :) - 2*q_elec/cosmo_c_struct%numat*scaled(j) !E-E
    end do
end subroutine rcnfldgrad_full

!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
!ONSAGER-TYPE POTENTIAL FOR GROUND STATE CALCULATION INCLUDING NUCLEAR-ELECTRONIC PART
!THIS POTENTIAL IS ADDED TO THE FOCK OPERATOR
!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
subroutine rcnfld_fock(qm2_params, qmmm_nml, cosmo_c_struct, qm2_struct, qmmm_struct, f, p, n)
    use cosmo_C, only : cosmo_C_structure !cosmo_c_struct%numat,cosmo_c_struct%fepsi,cosmo_c_struct%onsagE,cosmo_c_struct%onsager_radius;
    use constants, only : BOHRS_TO_A, AU_TO_EV, CODATA08_AU_TO_DEBYE
    use qmmm_struct_module, only : qmmm_struct_type
    use qmmm_module, only : qm2_structure
    use qm2_params_module, only : qm2_params_type
    use qmmm_nml_module, only : qmmm_nml_type

    implicit none;
    type(qm2_params_type), intent(inout) :: qm2_params
    type(qmmm_nml_type), intent(inout) :: qmmm_nml
    type(cosmo_C_structure), intent(inout) :: cosmo_c_struct
    type(qm2_structure), intent(inout) :: qm2_struct
    type(qmmm_struct_type), intent(inout) :: qmmm_struct
    _REAL_ f0((n + 1)*n/2), f((n + 1)*n/2), p((n + 1)*n/2)
    _REAL_ dip(3, n*(n + 1)/2);
    _REAL_ nuc_dip(3), scaled(3), elec_dip(3), Etest;
    integer n, i, j, k
    _REAL_ origin(3, cosmo_c_struct%numat)
    elec_dip = 0.d0; dip = 0.d0; Etest = 0.d0

    call centercoords(cosmo_c_struct, qmmm_struct, origin) !origin to center of charge distribution

    !!GET NUC DIP MAT and CALC NUC DIP
    call get_nuc_dip(qm2_params, qmmm_nml, qm2_struct, qmmm_struct, qmmm_struct%qm_coords - origin, dip);
    nuc_dip(1) = sum(dip(1, :))!NUCLEAR DIPOLE IN a.u. * angstrom
    nuc_dip(2) = sum(dip(2, :))
    nuc_dip(3) = sum(dip(3, :))
    dip = 0.d0

    !ELECTRIC DIPOLE
    call get_dipole_matrix(qm2_params, qmmm_nml, qm2_struct, qmmm_struct, qmmm_struct%qm_coords - origin, dip)
    i = 1
    do j = 1, n
        do k = 1, j
            if (j .eq. k) elec_dip = elec_dip + P(i)*dip(:, i) !diagonal
            if (j .ne. k) elec_dip = elec_dip + P(i)*dip(:, i)*2.d0 !off-diagonal
            i = i + 1
        end do
    end do

    !!CALCULATE SCALING FACTOR * INDUCED DIPOLE
    scaled = (cosmo_c_struct%fepsi/cosmo_c_struct%onsager_radius**3)*elec_dip*BOHRS_TO_A*AU_TO_EV

    !!CALCULATE REACTION FIELD POTENTIAL OPERATOR AND ADD TO FOCK MATRIX
    do i = 1, (n + 1)*n/2
        f0(i) = 2.d0*(scaled(1)*dip(1, i) + scaled(2)*dip(2, i) + scaled(3)*dip(3, i));
    end do
    f = f - f0
    cosmo_c_struct%onsagE = -sum((elec_dip + nuc_dip)**2)*cosmo_c_struct%fepsi/ &
        cosmo_c_struct%onsager_radius**3*BOHRS_TO_A*AU_TO_EV
    return
end subroutine rcnfld_fock

!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
!ONSAGER-TYPE POTENTIAL FOR GROUND STATE NUCLEAR-NUCLEAR PART
!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
subroutine rcnfldnuc(qm2_params, qmmm_nml, cosmo_c_struct, qm2_struct, qmmm_struct, enuclr)
    use qmmm_module, only : qm2_structure;
    use cosmo_C, only : cosmo_C_structure !cosmo_c_struct%numat,cosmo_c_struct%fepsi,cosmo_c_struct%onsager_radius
    use constants, only : one, BOHRS_TO_A, AU_TO_EV
    use qmmm_struct_module, only : qmmm_struct_type
    use qm2_params_module, only : qm2_params_type
    use qmmm_nml_module, only : qmmm_nml_type

    implicit none;
    type(cosmo_C_structure), intent(inout) :: cosmo_c_struct
    type(qm2_structure), intent(inout) :: qm2_struct
    type(qmmm_struct_type), intent(inout) :: qmmm_struct
    type(qm2_params_type), intent(inout) :: qm2_params
    type(qmmm_nml_type), intent(inout) :: qmmm_nml
    _REAL_ dip(3, qm2_struct%norbs*(qm2_struct%norbs + 1)/2)
    _REAL_ nuc_dip(3), scaled(3)
    _REAL_ enuclr, origin(3, cosmo_c_struct%numat)
    integer n
    n = qm2_struct%norbs
    dip = 0.d0

    call centercoords(cosmo_c_struct, qmmm_struct, origin)
    !!GET NUC DIP MAT and CALC NUC DIP
    call get_nuc_dip(qm2_params, qmmm_nml, qm2_struct, qmmm_struct, qmmm_struct%qm_coords - origin, dip);
    nuc_dip(1) = sum(dip(1, :))!NUCLEAR DIPOLE IN a.u. * angstrom
    nuc_dip(2) = sum(dip(2, :))
    nuc_dip(3) = sum(dip(3, :))

    !!CALCULATE SCALING FACTOR * INDUCED DIPOLE
    scaled = (cosmo_c_struct%fepsi/cosmo_c_struct%onsager_radius**3)*nuc_dip*BOHRS_TO_A*AU_TO_EV

    !CALCULATE NUCLEAR-NUCLEAR + NUCLEAR-ELECTRONIC ENERGIES
    enuclr = enuclr - sum(scaled*nuc_dip)
end subroutine rcnfldnuc

!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
!ONSAGER-TYPE POTENTIAL FOR NUCLEAR-ELECTRONIC PART
!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
subroutine rcnfldhcr(qm2_params, qmmm_nml, cosmo_c_struct, qm2_struct, qmmm_struct, h)
    use qmmm_module, only : qm2_structure;
    use cosmo_C, only : cosmo_C_structure !cosmo_c_struct%numat,cosmo_c_struct%fepsi,cosmo_c_struct%onsager_radius
    use constants, only : one, BOHRS_TO_A, AU_TO_EV
    use qmmm_struct_module, only : qmmm_struct_type
    use qm2_params_module, only : qm2_params_type
    use qmmm_nml_module, only : qmmm_nml_type

    implicit none;
    type(qm2_params_type), intent(inout) :: qm2_params
    type(qmmm_nml_type), intent(inout) :: qmmm_nml
    type(cosmo_C_structure), intent(inout) :: cosmo_c_struct
    type(qm2_structure), intent(inout) :: qm2_struct
    type(qmmm_struct_type), intent(inout) :: qmmm_struct
    _REAL_ dip(3, qm2_struct%norbs*(qm2_struct%norbs + 1)/2)
    _REAL_ nuc_dip(3), scaled(3), elec_dip(3), Etest
    _REAL_ h(qm2_struct%norbs*(qm2_struct%norbs + 1)/2)
    _REAL_ h0(qm2_struct%norbs*(qm2_struct%norbs + 1)/2)
    _REAL_ origin(3, cosmo_c_struct%numat)
    integer n, i, j, k
    n = qm2_struct%norbs
    dip = 0.d0
    Etest = 0.d0

    call centercoords(cosmo_c_struct, qmmm_struct, origin)
    !!GET NUC DIP MAT and CALC NUC DIP
    call get_nuc_dip(qm2_params, qmmm_nml, qm2_struct, qmmm_struct, qmmm_struct%qm_coords - origin, dip);
    nuc_dip(1) = sum(dip(1, :))!NUCLEAR DIPOLE IN a.u. * angstrom
    nuc_dip(2) = sum(dip(2, :))
    nuc_dip(3) = sum(dip(3, :))
    dip = 0.d0

    call get_dipole_matrix(qm2_params, qmmm_nml, qm2_struct, qmmm_struct, qmmm_struct%qm_coords - origin, dip)
    i = 1
    do j = 1, n
        do k = 1, j
            if (j .eq. k) elec_dip = elec_dip + qm2_struct%den_matrix(i)*dip(:, i) !diagonal
            if (j .ne. k) elec_dip = elec_dip + qm2_struct%den_matrix(i)*dip(:, i)*2.d0 !off-diagonal
            i = i + 1
        end do
    end do

    !!CALCULATE SCALING FACTOR * INDUCED DIPOLE
    scaled = (cosmo_c_struct%fepsi/cosmo_c_struct%onsager_radius**3)*nuc_dip*BOHRS_TO_A*AU_TO_EV

    !CALCULATE NUCLEAR-ELECTRONIC and ELECTRONIC-NUCLEAR ENERGIES
    do i = 1, (n + 1)*n/2
        h0(i) = -2*(scaled(1)*dip(1, i) + scaled(2)*dip(2, i) + scaled(3)*dip(3, i));
    end do
    h = h + h0
end subroutine rcnfldhcr

!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
!SUBROUTINE FOR CONSTANT ELECTRIC FIELD SCREENING
!OF ELECTRON-ELECTRON INTERACTION
!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
subroutine efield_fock(qm2_params, qmmm_nml, cosmo_c_struct, qm2_struct, qm2ds, qmmm_struct, f, n)
    use qmmm_module, only : qm2_structure;
    use cosmo_C, only : cosmo_C_structure !Ex,Ey,Ez
    use constants, only : one, BOHRS_TO_A, AU_TO_EV
    use qm2_davidson_module
    use qmmm_struct_module, only : qmmm_struct_type
    use qm2_params_module, only : qm2_params_type
    use qmmm_nml_module, only : qmmm_nml_type

    implicit none;
    type(qm2_params_type), intent(inout) :: qm2_params
    type(qmmm_nml_type), intent(inout) :: qmmm_nml
    type(cosmo_C_structure), intent(inout) :: cosmo_c_struct
    type(qm2_structure), intent(inout) :: qm2_struct
    type(qm2_davidson_structure_type), intent(inout) :: qm2ds
    type(qmmm_struct_type), intent(inout) :: qmmm_struct
    integer n, k;
    _REAL_ f(n*(n + 1)/2);
    _REAL_ tmp(n*(n + 1)/2);
    _REAL_ dip(3, n*(n + 1)/2);
    _REAL_ origin(3, qmmm_struct%nquant_nlink)
    _REAL_ ddot
    _REAL_ GSDM(n, n), mu_gr(3)
    tmp = 0.d0
    dip = 0.d0
    origin = 0.d0;
    call centercoords(cosmo_c_struct, qmmm_struct, origin)
    !!GET ELEC DIP MATRIX
    call get_dipole_matrix(qm2_params, qmmm_nml, qm2_struct, qmmm_struct, qmmm_struct%qm_coords - origin, dip) !dipole in au * A
    call unpacking(qm2ds%Nb, qm2_struct%den_matrix, GSDM, 's')
    do k = 1, 3  ! loop over x,y,z
        call unpacking(qm2ds%Nb, dip(k, :), qm2ds%eta_scratch, 's')
        mu_gr(k) = ddot(qm2ds%Nb**2, GSDM, 1, qm2ds%eta_scratch, 1)/BOHRS_TO_A
    end do
    !!CALCULATE ELECTRIC FIELD POTENTIAL OPERATOR
    tmp = cosmo_c_struct%Ex*dip(1, :) + cosmo_c_struct%Ey*dip(2, :) + cosmo_c_struct%Ez*dip(3, :); !now in hartree
    f = f + tmp/BOHRS_TO_A
    return
end subroutine efield_fock

!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
!SUBROUTINE FOR CONSTANT ELECTRIC FIELD SCREENING
!OF NUCLEAR-NUCLEAR INTERACTION
!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
subroutine efield_nuc(qm2_params, qmmm_nml, cosmo_c_struct, qm2_struct, qmmm_struct, enuclr)
    use qmmm_module, only : qm2_structure;
    use cosmo_C, only : cosmo_C_structure !Ex,Ey,Ez
    use constants, only : BOHRS_TO_A, AU_TO_EV
    use qmmm_struct_module, only : qmmm_struct_type
    use qm2_params_module, only : qm2_params_type
    use qmmm_nml_module, only : qmmm_nml_type

    implicit none;
    type(qm2_params_type), intent(inout) :: qm2_params
    type(qmmm_nml_type), intent(inout) :: qmmm_nml
    type(cosmo_C_structure), intent(inout) :: cosmo_c_struct
    type(qm2_structure), intent(inout) :: qm2_struct
    type(qmmm_struct_type), intent(inout) :: qmmm_struct
    _REAL_ dip(3, qm2_struct%norbs*(qm2_struct%norbs + 1)/2)
    _REAL_ nuc_dip(3)
    _REAL_ enuclr, origin(3, qmmm_struct%nquant_nlink)
    origin = 0.d0; dip = 0.d0
    call centercoords(cosmo_c_struct, qmmm_struct, origin)
    !!GET NUC DIP MAT and CALC NUC DIP
    call get_nuc_dip(qm2_params, qmmm_nml, qm2_struct, qmmm_struct, qmmm_struct%qm_coords - origin, dip);
    write (6, *) 'Nuclear Dipole:', sum(dip(1, :))/BOHRS_TO_A, &
        sum(dip(2, :))/BOHRS_TO_A, &
        sum(dip(3, :))/BOHRS_TO_A
    nuc_dip(1) = cosmo_c_struct%Ex*sum(dip(1, :))!NUCLEAR DIPOLE IN a.u. * angstrom
    nuc_dip(2) = cosmo_c_struct%Ey*sum(dip(2, :)) !Now in hartree
    nuc_dip(3) = cosmo_c_struct%Ez*sum(dip(3, :))
    !CALCULATE NUCLEAR-NUCLEAR ENERGY
    enuclr = enuclr + sum(nuc_dip)/BOHRS_TO_A!/2.d0
    return
end subroutine efield_nuc

!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
!CALCULATE COORDINATE MOMENT
!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
subroutine centercoords(cosmo_c_struct, qmmm_struct, origin)
    use cosmo_C, only : cosmo_C_structure !cosmo_c_struct%numat
    use qmmm_struct_module, only : qmmm_struct_type

    implicit none;
    type(cosmo_C_structure), intent(inout) :: cosmo_c_struct
    type(qmmm_struct_type), intent(inout) :: qmmm_struct
    integer :: j

    _REAL_  :: origin(3, cosmo_c_struct%numat)
    origin = 0.d0
    do j = 1, 3
        origin(j, :) = origin(j, :) + sum(qmmm_struct%qm_coords(j, :))/cosmo_c_struct%numat
    end do
end subroutine centercoords
